
/**
 * 進捗情報。
 * <p>
 * 長時間の処理を行う際に、その進捗状況をイベントで報告するオブジェクト。
 * 進捗状況の%値と、進捗に応じたタイトルの変更がイベントとして通知される。
 * これにより、現在どのような処理を行っており、全体の何%であるかがわかる。
 * </p>
 * <h2>基本的な考え方</h2>
 * <p>
 * そもそも複雑な処理について、それを行う前に全体の作業数（経過時間）をあらかじめ正確に把握するのは不可能である。そうではなく、
 * 大まかな数を見積もっておき、その進捗を報告するにとどめる。
 * 例えば、データベースから特定の値を取り出し、それをネットワーク上に送信するという作業を考えてみると、この場合には、
 * 大きく二つの処理があり、それぞれの処理にその詳細がある。この場合は以下の方針をとる。
 * </p>
 * <ul>
 * <li>全体を二分割する
 * <li>第一処理の分割数をDBのレコード数とし、レコードの処理済数を進捗として報告する。
 * <li>第二処理の分割数をデータ送信数として、送信済データ数を進捗として報告する。
 * </ul>
 * <p>
 * 例えば、レコード数が1000で、送信データ数が100であったとする。全体は二分割されており、50%ずつであるから、前半の処理で一つのレコードを処理すると、
 * (50 / 1000)%進捗したことになり、後半で一つのデータを送信すると、(50/100)%進捗したことになる。
 * </p>
 * <p>
 * つまり、最初は1であったものを2分割し、前半を1000分割、後半を100分割し、それぞれの進捗を報告していくと、全体の%が報告されることになる。
 * </p>
 * <h2>最も単純な場合</h2>
 * <p>
 * 最初にトップオブジェクトを作成するが、この分割数は常に１である。
 * </p>
 * <pre>
 * Progress p = new Progress();
 * p.addListener(ProgEvent.class, e-> { ... });
 * p.done(); // p.incProgress()
 * </pre>
 * <p>
 * とすると、p.done()時に完了イベント{@link ProgDoneEvent}が通知される。
 * もちろんこれでは、100%になったことしかわからない。また、この場合のタイトル変更は通知されない。
 * </p>
 * <p>
 * また、この場合はp.done()でも、p.incProgress()でもどちらでも良い。後者は、進捗を1だけ進めるものだが、この場合の分割数は1であるため、
 * 一度のincProgress()呼び出しで処理は完了する。
 * </p>
 * <h2>トップを分割する</h2>
　* <p>
 * </p>
 */
package com.cm55.progress;